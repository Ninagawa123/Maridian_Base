Teensyの[7-3]のシーケンシャルなモーションデータの再生についての予定  
まだコード化していませんが、下記のようなものを考えています。  
  
  
■ まず、モーション用の配列を２つ準備する  
配列１ デフォルトポーズ用  
{  
[[フレーム数],[サーボID0のモード],[サーボID0の目標位置]],// ①ホームポジションのポーズ  
}  
  
配列２ モーションデータ用  
{  
[[フレーム数],[サーボID0のモード],[サーボID0の目標位置]],// ② １コマ目のポーズ  
[[フレーム数],[サーボID0のモード],[サーボID0の目標位置]],// ③ 2コマ目のポーズ  
[[フレーム数],[サーボID0のモード],[サーボID0の目標位置]],// ④ ホームポジションのポーズ  
}  
  
モーション用の配列はmeridim配列より１次元多い配列になります。  
  
■ この時、モーション用の配列はmeridim配列に対応するようにしておきます  
具体的には、  
フレーム数はmeridim[19],  
サーボID0のモードはmeridim[20],  
サーボID0の目標位置はmeridim[21]となる。  
（meridim配列をモーション配列に変換できるようにしておきたい。）  
  
■ 配列に入れるフレーム数の扱い  
フレーム数には、10msを１フレームとして、何フレームかけてそのポーズを目指すかを入れます。  
ちなみにフレーム数はちょっと加工してイージングのモードも入れるようにするつもりですが、とりあえず忘れてください。  
  
■ モーション再生のアルゴリズムとしては...  
まず、②③④のフレーム数の合計をカウンタ上限としてキープする。  
カウンタAとカウンタBを0にする。  
[7-3]を通過するたびにカウンタAをカウントアップ。 カウンタAが上限に達するまで以下を実行する。  
 　　カウンタBが②のフレーム数に達するまで下記を実行する。  
　　　　カウンタBをカウントアップ  
　　　　サーボの目標位置の②ー①をフレーム数で割ったものxカウンタB を  
 　　　　①に足す（これがモーションの目標値として[8-3]に送ら実行される）  
 　　②の処理が終了したら③、④と移動していく。for文を階層的に回す。  
 　④まで終了すると、ちょうどカウンタAも上限に達するはず。  

という感じを予定しています。
もっとクレバーな方法があるかも。
